\chapter{Usprawnienia Glasgow Haskell Compiler}\label{chap:badania}
\todo[disable,inline,size=\tiny]{Ten rozdział zawiera opis wyników uzyskanych w~ramach pracy. Jeśli praca miała
cel badawczy należy skupić się na opisie przeprowadzonych eksperymentów oraz
prezentacji i~analizie uzyskanych wyników. Jeśli praca nie miała na celu
uzyskania nowatorskich wyników, należy skupić się na opisie architektury
stworzonej aplikacji. W~obu przypadkach podstawowym celem tego rozdziału jest
realizacja celów postawionych w~rozdziale \ref{sec:cele_pracy}. Rozdział ten ma
bezspornie pokazywać, że cele pracy zostały zrealizowane}

\sectionex{Zgłoszenie nr 10839}{Consistent pretty-printing of type families}
\label{sec:zgloszenie_10839}

Pierwszym z wykonanych w pracy usprawnień było ujednolicenie wyświetlania rodzin typów. Problem polegał na tym, iż w zależności od miejsca i rodzaju błędu, wyświetlane były one w różny sposób. Co gorsza różniły się one nie tylko formatem, ale też tym, które informacje zawierają. Widać to na poniższych wycinkach z komunikatów generowanych przez kompilator. We fragmencie \ref{lst:consistent_conflicting_before} z błędem w otwartej rodzinie typów widoczna jest lewa strona równań i wskazania, w którym miejscu w pliku się one znajdują.

\begin{lstlisting}[numbers=left,firstnumber=4,label={lst:consistent_conflicting_code},
                   caption={Fragment testu T7524 z dwoma równaniami otwartej rodziny typów będącymi w konflikcie.}]
type family F (a :: k1) (b :: k2)
type instance F a a = Int
type instance F a b = Bool
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:consistent_conflicting_before},
                   caption={Błąd generowany przez kompilator w przypadku \ref{lst:consistent_conflicting_code} przed wprowadzeniem zmian.}]
T7524.hs:5:15:
    Conflicting family instance declarations:
      F a a -- Defined at T7524.hs:5:15
      F a b -- Defined at T7524.hs:6:15
\end{lstlisting}

We fragmencie \ref{lst:consistent_overlapped_before} z zamkniętą rodziną typów widoczna jest zarówno lewa jak i prawa strona równania. Nie jest jednak podane miejsce wystąpienia.

\begin{lstlisting}[numbers=left,firstnumber=70,label={lst:consistent_overlapped_code},
                   caption={Fragment testu T6018 z zamkniętą rodziną typów z równaniami o nachodzących na siebie dziedzinach.}]
-- This is similar, except that the last equation contains concrete type.  Since
-- it is overlapped it should be dropped with a warning
type family Foo a = r | r -> a where
    Foo Int  = Bool
    Foo Bool = Int
    Foo Bool = Bool
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:consistent_overlapped_before},
                   caption={Ostrzeżenie generowane przez kompilator w przypadku \ref{lst:consistent_overlapped_code} przed wprowadzeniem zmian.}]
T6018.hs:75:5: Warning:
    Type family instance equation is overlapped:
      Foo Bool = Bool
\end{lstlisting}

W \ref{lst:consistent_injectivity_before} wyświetlany jest kwantyfikator wiążący zmienne równania i obie strony równania, ale brak jest wcięcia, przez co równanie jest wyrównanie w pionie z resztą komunikatu i cierpi czytelność komunikatu. Brak jest również lokalizacji.

\begin{lstlisting}[numbers=left,firstnumber=64,label={lst:consistent_injectivity_code},
                   caption={Fragment testu T6018fail z równaniem rodziny typów nie spełniającej warunku różnowartościowości.}]
-- This should fail because there is no way to determine k from the RHS
type family Fc (a :: k) (b :: k) = r | r -> k
type instance Fc a b = Int
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:consistent_injectivity_before},
                   caption={Błąd generowany przez kompilator w przypadku \ref{lst:consistent_injectivity_code} przed wprowadzeniem zmian.}]
T6018fail.hs:66:15: error:
    Type family equation violates injectivity annotation.
    Kind variable ‘k’ cannot be inferred from the right-hand side.
    (enabling -fprint-explicit-kinds might help)
    In the type family equation:
    forall (k :: BOX) (a :: k) (b :: k). Fc a b = Int
\end{lstlisting}


\subsection{Rozwiązanie} %%%

Po zapoznaniu się z kod GHC, udało się odnaleźć miejsca odpowiadające za każdy z tych komunikatów. Są to odpowiednio funkcja \code{inaccessibleCoAxBranch} dla \ref{lst:consistent_overlapped_before}, \code{pprCoAxBranch} w przypadku \ref{lst:consistent_injectivity_before} i \code{pprCoAxBranchHdr} w przypadku \ref{lst:consistent_conflicting_before}. Znaleziono jeszcze inną funkcję \code{pprCoAxiom}, używaną do generowania komunikatów przy kompilacji z flagą \code{-ddump-types}. Wszystkie one służyły do prezentowania rodzin typów w komunikatach, lecz były zaimplementowane osobno. Stąd nietrudno było o rozbieżności.

Dokonano usprawnienia, które polegało na zrefaktorowaniu kodu i wydzieleniu części wspólnej do osobnej funkcji \code{ppr\_co\_ax\_branch}. Została ona napisana tak, by wyświetlać wszystkie informacje, które wydobywały zastąpione funkcje. W komunikacie znajduje się zatem jawny kwantyfikator, wyświetlany tylko przy kompilacji z odpowiednią flagą lub jeżeli rodzina typów wykorzystuje polimorfizm na poziomie rodzajów jak w przykładzie \ref{lst:consistent_injectivity_before}, obie strony równania i miejsce wystąpienia w kodzie kompilowanego programu.

W trakcie pracy okazało sie, że rodziny typów danych wymagają innego sposobu wyświetlania prawej strony równania. Jest tak, gdyż ich reprezentacja na etapie sprawdzania typów zawiera wygenerowany przez kompilator konstruktor typu, o którym użytkownik może nie wiedzieć. Z tego powodu \code{pprCoAxBranch} używa funkcji \code{pprDataCons}, która wydobywa z tego wewnętrznego konstruktora typu konstruktory wartości i odtwarza prawą stronę równania taką, jaką podał użytkownik. Przykład działania widoczny jest we fragmencie \ref{lst:consistent_datafams_after}. Wcześniej prawa strona nie była wcale w tym przypadku wcale wyświetlana, co widać na wycinku \ref{lst:consistent_datafams_before}.

\begin{lstlisting}[numbers=left,firstnumber=13,label={lst:consistent_datafams_code},
                   caption={Fragment testu T9371 z rodziną typów danych powiązaną z klasą \code{C} i równaniami o nachodzących na siebie dziedzinach.}]
instance {-# OVERLAPPABLE #-} Monoid x => C x where
    data D x = D1 (Either x ())
    makeD = D1 (Left mempty)

instance (Monoid x, Monoid y) => C (x, y) where
    data D (x,y) = D2 (x,y)
    makeD = D2 (mempty, mempty)
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:consistent_datafams_before},
                   caption={Błąd generowany przez kompilator w przypadku \ref{lst:consistent_datafams_before} przed wprowadzeniem zmian.}]
T9371.hs:14:10:
    Conflicting family instance declarations:
      D -- Defined at T9371.hs:14:10
      D (x, y) -- Defined at T9371.hs:18:10
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:consistent_datafams_after},
                   caption={Błąd generowany przez kompilator w przypadku \ref{lst:consistent_datafams_after} przed wprowadzeniem zmian.}]
T9371.hs:14:10:
    Conflicting family instance declarations:
      D = D1 (Either x ()) -- Defined at T9371.hs:14:10
      D (x, y) = D2 (x, y) -- Defined at T9371.hs:18:10
\end{lstlisting}

Inaczej wygląda to w przypadku funkcji \code{pprCoAxiom}, która jest używana przy generowaniu zrzutu z type-checkera przy kompilacji z odpowiednią flagą. Tutaj pożądane jest wyświetlenie wewnętrznej reprezentacji i \code{pprDataCons} nie jest używana. Przykładowy efekt widać na przykładzie \ref{lst:consistent_tcdump}.

\begin{lstlisting}[language={},label={lst:consistent_tcdump},caption={Fragment oczekiwanego zrzutu z type-checkera testu DataFamilyInstanceLHS z wyświetlonym równaniem rodziny typów danych.}]
COERCION AXIOMS
  axiom DataFamilyInstanceLHS.TFCo:R:SingMyKind_ ::
    Sing = DataFamilyInstanceLHS.R:SingMyKind_
      -- Defined at DataFamilyInstanceLHS.hs:8:15
\end{lstlisting}

Przy okazji tego zadania wprowadzony został również drobny refaktoring polegający na wprowadzeniu osobnej funkcji \code{vbar} reprezentującej komunikat \code{"|"}. Definiowane wcześniej lokalnie wystąpienia tego komunikatu zostały zastąpione.

\subsection{Testy} %%%

Do tego zadania nie zostały utworzone nowe testy. Jako że wprowadzona zmiana dotyczyła komunikatów o błędach, istniejące już testy pokrywały ją w wystarczającym stopniu. Dwadzieścia dziewięć testów wykazało wprowadzone przy tym zgłoszeniu zmiany i zostały uaktualnione, by oczekiwać nowych komunikatów. Fragmenty testów \ref{lst:consistent_conflicting_code}, \ref{lst:consistent_injectivity_code} i \ref{lst:consistent_overlapped_code} zaprezentowane wcześniej również wywołały inne komunikaty, które przedstawiono na wycinkach \ref{lst:consistent_conflicting_code}, \ref{lst:consistent_injectivity_code} i \ref{lst:consistent_overlapped_code}.

\begin{lstlisting}[language={},label={lst:consistent_conflicting_after},
                   caption={Błąd generowany przez kompilator w przypadku \ref{lst:consistent_conflicting_code} po wprowadzeniu zmian.}]
T7524.hs:5:15:
    Conflicting family instance declarations:
      forall (k :: BOX) (a :: k). F a a = Int -- Defined at T7524.hs:5:15
      forall (k :: BOX) (k1 :: BOX) (a :: k) (b :: k1).
        F a b = Bool -- Defined at T7524.hs:6:15
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:consistent_overlapped_after},
                   caption={Ostrzeżenie generowane przez kompilator w przypadku \ref{lst:consistent_overlapped_code} po wprowadzeniu zmian.}]
T6018.hs:75:5: Warning:
    Type family instance equation is overlapped:
      Foo Bool = Bool -- Defined at T6018.hs:75:5
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:consistent_injectivity_after},
                   caption={Błąd generowany przez kompilator w przypadku \ref{lst:consistent_injectivity_code} po wprowadzeniu zmian.}]
T6018fail.hs:66:15: error:
    Type family equation violates injectivity annotation.
    Kind variable ‘k’ cannot be inferred from the right-hand side.
    (enabling -fprint-explicit-kinds might help)
    In the type family equation:
      forall (k :: BOX) (a :: k) (b :: k).
        Fc a b = Int -- Defined at T6018fail.hs:66:15
\end{lstlisting}

Wszystkie trzy komunikaty mają ten sam format. Zawierają obie strony równania i lokalizację oraz takie same wcięcia, wyróżniające je od pozostałej części błędu. Dwa fragmenty, w których użyta została zmienna \code{k} są wyświetlane z kwantyfikatorem, choć wcześniej w przypadku \ref{lst:consistent_conflicting_code} informacja o polimorfizmie na poziomie rodzajów typów była niewidoczna.


\sectionex{Zgłoszenie nr 10982}{Warn about unused pattern variables in type families}
\label{sec:zgloszenie_10982}

Zgłoszenie to polegało na dodaniu ostrzeżeń o nieużywanych zmiennych w funkcjach na poziomie typu, działających analogicznie do obecnych już w GHC ostrzeżeń w funkcjach na poziomie termów. Są one uaktywniane tą samą flagą \code{-fwarn-unused-matches}, domyślnie nie są wyświetlane.

Ważnym zagadnieniem okazało się zdefiniowanie, kiedy zmienna typu uważana jest za używaną. W zaimplementowanej wersji, by ostrzeżenie nie było generowane, zmienna musi występować po prawej stronie równania lub występować przynajmniej dwa razy po lewej stronie równania. Obie sytuacje są pokazane we fragmencie \ref{lst:unused_used_examples}

\begin{lstlisting}[label={lst:unused_used_examples},
                   caption={Przykład funkcji na poziomie typów ze zmiennymi uznawanymi za wykorzystywane.}]
type family X a where
  X a = a

type family Y a b where
  Y a a = Int
\end{lstlisting}

Aby ostrzeżenie nie wystąpiło, gdy zmienna jest nieużywana, należy zastąpić ją lub poprzedzić podkreślnikiem. Pokazane to zostało we fragmencie \ref{lst:unused_underscore_examples}.

\begin{lstlisting}[label={lst:unused_underscore_examples},
                   caption={Przykład funkcji na poziomie typów ze zmiennymi zastąpionymi lub poprzedzonymi podkreślnikami.}]
type family D a b where
  D a _b = a

type family E a b where
  E a _ = a
\end{lstlisting}

\subsection{Rozwiązanie} %%%

Wyświetlania ostrzeżeń dokonano przez zmiany w renamerze. Po analizie kodu udało się stwierdzić, że funkcja \code{rnFamInstDecl} odpowiada za wszystkie rodziny typów w kodzie, otwarte, zamknięte i związane z klasą. Ponadto jest już w niej używana funkcja \code{extractHsTysRdrTyVars}, która przechodzi po typie, kolekcjonując nazwy zmiennych, by utworzyć z nich zmienne typów. Zbiór zmiennych używanych to z kolei to samo, co zbiór zmiennych wolnych w prawej stronie równania, zwracany przez funkcję \code{rnPayload}. Większość informacji potrzebnych do realizacji założeń zgłoszenia było zatem dostępnych od początku, potrzebne było pozyskanie informacji o duplikatach.

W tym celu zastąpiona funkcja \code{extractHsTysRdrTyVars} zastąpiona została bardzo podobną \code{extractHsTysRdrTyVarsDups}, która zwraca wszystkie wystąpienia zmiennych z typu i nie usuwa wielokrotnych wystąpień tej samej nazwy. To umożliwiło sprawdzanie drugiego z warunków, kiedy zmienna jest uznawana za używaną.

Do wygenrowania ostrzeżeń użyta została funkcja \code{warnUnusedMatches}, ta sama, która odpowiada za ostrzeżenia w funkcjach na poziomie termów. Gwarantuje to, że ostrzeżenia te są w tym samym formacie. Następuje w niej również odczytanie ze środowiska globalnego w monadzie renamera, czy opcja generowania ostrzeżeń została wybrana przez programistę, na przykład przez ustawienie flagi \code{-fwarn-unused-matches} lub \code{-Wall}.

Ignorowanie zmiennych zaczynających się od podkreślnika zachodzi w \code{warnUnusedMatches} przez zwyczajne sprawdzenie pierwszego znaku nazwy. Z kolei anonimowe i nazwane symbole wieloznaczne nie wywołują ostrzeżeń, gdyż nie są kolekcjonowane w funkcji \code{extractHsTysRdrTyVarsDups}, więc wcale nie znajdują się na liście nazw.

Zmiana wymagała przejrzenia rodzin typów w GHC oraz powiązanych bibliotekach i uaktualnienia ich tak, by nie generowały ostrzeżeń. W przeciwnym proces walidacji kończyłby się błędem, gdyż został on skonfigurowany, by nie dopuszczać ostrzeżeń w pewnych częściach projektu. Z tego powodu konieczne było stworzenie niewielkiej łatki do biblioteki Hoopl, w której poprzedzono problematyczne zmienne podkreślnikami. Bez żadnych przeszkód znalazła się ona w repozytorium tego projektu.

\subsection{Testy} %%%

Testami sprawdzającymi działanie usprawnienia są \code{UnusedTyVarWarnings} i \code{UnusedTyVarWarningsNamedWCs}. Oba działają przez próbę kompilacji pewnego programu i sprawdzenie, czy na wyjściu kompilatora pojawiają się oczekiwane ostrzeżenia. Program ten zawiera jedenaście przykładów rodzin typów otwartych, zamkniętych lub rodzin typów danych. Spośród ich równań są przypadki zmiennych nieużywanych, używanych ze względu na wystąpienie po prawej stronie i używanych ze względu na wielokrotne wystąpienie po lewej stronie, z nazwą poprzedzoną podkreślnikiem oraz symboli wieloznacznych. Testy te różnią się od siebie tym, iż w przypadku \code{UnusedTyVarWarningsNamedWCs} kompilacja zachodzi z uaktywnionym rozszerzeniem \code{NamedWildCards}. Ma to związek ze zgłoszeniem opisanym w sekcji \ref{sec:zgloszenie_11098}

Fragment \ref{lst:unused_test_code} to część jednego z opisanych testów. Z kolei fragment \ref{lst:unused_test_stderr} to ostrzeżenia, które są dla niego oczekiwane.
\begin{lstlisting}[numbers=left,firstnumber=7,label={lst:unused_test_code},
                   caption={Fragment testu \code{UnusedTyVarWarnings} z równaniami wywołującymi ostrzeżenia lub zawierającymi zmienne poprzedzone podkreślnikiem.}]
type family C a b where
  C a b = a                 -- should warn

type family C2 a b
type instance C2 a b = a    -- should warn

type family D a b where
  D a _b = a                -- should not warn

type family D2 a b
type instance D2 a _b = a   -- should not warn
\end{lstlisting}

\begin{lstlisting}[language={},label={lst:unused_test_stderr},
                   caption={Ostrzeżenia generowany przez kompilator dla fragmentu \ref{lst:unused_test_code} po wprowadzeniu zmian.}]
UnusedTyVarWarnings.hs:8:5: warning:
    Defined but not used: type variable ‘b’

UnusedTyVarWarnings.hs:11:18: warning:
    Defined but not used: type variable ‘b’
\end{lstlisting}

Dodanie nowej funkcji wymagało jeszcze uaktualnienia dokumentacji. Informacje o dodanych ostrzeżeniach zostały dodane do przewodnika użytkownika w części z opisem opcjonalnych ostrzeżeń, w części z opisem rodzin typów i dodziennika zmian,


\sectionex{Zgłoszenie nr 11098}{PartialTypeSignatures mishandles type variables that begin with an underscore}
\label{sec:zgloszenie_11098}

W tym zgłoszeniu konieczne było naprawienie błędu związanego z rozszerzeniem \code{NamedWildCards}. Problem ten napotkany został w czasie pracy nad zgłoszeniem nr 10982 opisanym w sekcji \ref{sec:zgloszenie_10982}, gdy zbadano jak uaktywnienie tego rozszerzenia wpływa na nazwane symbole wieloznaczne w rodzinach typów. Stąd został wybrany po tamtym zgłoszeniu.

Opis błędu początkowo skupiał się na przypadku, w którym zmienna typu z nazwą zaczynającą się od podkreślnika, lecz związana jawnie kwantyfikatorem, była mimo to traktowana jako nazwany symbol wieloznaczny. Przypadek ten został pokazany na wycinku \ref{lst:namedwcs_explicit_forall}. Problem okazał się jednak wpływać na więcej programów. Uaktywnienie \code{NamedWildCards} powodowało błędy kompilacji, gdy zmienna typu zaczynająca się od podkreślnika znalazła się w poza sygnaturą typu. Znaczenie symboli wieloznacznych w sygnaturach jest dobrze określone w specyfikacji \code{PartialTypeSignatures}, lecz nie są one oczekiwane poza nimi. Przykładowy kod demonstrujący błędy w różnych konstekstach znajduje się we fragmencie \ref{lst:namedwcs_not_allowed}.

\begin{lstlisting}[numbers=left,firstnumber=13,label={lst:namedwcs_explicit_forall},
                   caption={Fragment testu \code{NamedWildcardExplicitForall} sprawdzającego, czy zmienne związane kwantyfikatorem nie zostają zamienione w wieloznaczniki.}]
baz :: forall _a . _a -> _b -> (_a, _b)    -- _a is a variable, _b is a wildcard
baz x y = (not x, not y)

qux :: _a -> (forall _a . _a -> _a) -> _a  -- the _a bound by forall is a tyvar
qux x f = let _ = f 7 in not x             -- the other _a are wildcards
\end{lstlisting}

\begin{lstlisting}[label={lst:namedwcs_not_allowed},
                   caption={Deklaracje, w których kompilacja kończyła się błędem, przy aktywnym rozszerzeniu \code{NamedWildCards}.}]
type Synonym _a = _a -> _a
-- "Unexpected type '_a' In the type declaration for 'Synonym'"

data A a _b = ACon a a
-- "Unexpected type '_b' In the data declaration for 'A'"

data B _a b = BCon _a _a
-- "Unexpected type '_a' In the data declaration for 'B'"

type family C a b where
  C a _b = a -> a
-- "Wildcard '_b' not allowed in a type pattern of family instance for 'C'"

type family D a b where
  D _a b = _a -> _a
-- "Wildcard '_a' not allowed in a type pattern of family instance for 'D'"
-- "Wildcard '_a' not allowed in the declaration for type synonym 'D'" (twice)

data family E a b
data instance E a _b = ECon a a
-- "Wildcard '_b' not allowed in a type pattern of family instance for 'E'"

data family F a b
data instance F _a b = FCon _a _a
-- "Wildcard '_a' not allowed in a type pattern of family instance for 'F'"
-- "Wildcard '_a' not allowed in the definition of data constructor 'FCon'" (twice)
\end{lstlisting}

Jak widać z uaktywnioną opcją \code{NamedWildCards} kompilacja wielu poprawnych programów kończyła się błędem. Zmienne zaczynające się od podkreślnika są w Haskellu od dawna i nie ma powodu, by były niedouszczalne w tej sytuacji. Zgłoszenie polegało na dokonaniu takich zmian w GHC, by nie były one już źródłem błędów.

\subsection{Rozwiązanie} %%%

Źródłem problemów było rozwinięcie \code{tyvar} w definicji gramatyki programu Happy. Początkowo generowało ono taki parser, który w sytuacji, gdy rozszerzenie\code{NamedWildCards} jest aktywne, wszystkie zmienne zaczynające się od podkreślników parsował jako nazwane wieloznaczniki.

Wykorzystany pomysł na rozwiązanie problemu był taki, by parsować wszystkie identyfikatory jako zwykłe zmienne typów, a następnie zamieniać część z nich w renamerze. Rzeczywiście, w ramach pracy dokonano zmian w \code{Parser.y}, by bezwarunkowo konstruowane były \code{HsTyVar}, reprezentujące zmienne typu.

Do rekordu \code{LocalRdrEnv} przekazywanego w monadzie renamera dodane zostało pole \code{lre\_nwcs}, będące zbiorem nazw zmiennych, które powinny zostać zastąpione przez symbole wieloznaczne. Rozwiązanie problemu z fragmentu \ref{lst:namedwcs_not_allowed} uzyskano poprzez kontrolę, kiedy ten zbiór ma być wypełniany. Umieszczane są w nim bowiem na wolne zmienne zaczynające sie od podkreślnika, lecz wyłącznie w funkcjach, które operują na typie \code{LHsSigWcType}. Tym bowiem cechują się funkcje, którymi dokonywane jest zastępowanie nazw w kontekstach dopuszczających nazwane symbole wieloznaczne. Do tego zbiór pozostaje pusty, gdy opcja \code{NamedWildCards} jest nieaktywna.

Zbiór ten jest wykorzystywany w funkcjach \code{rnWcSigTy} i \code{rnHsTyKi}, w wariantach oczekujących argumentów o wartości \code{HsForAllTy}, czyli reprezentujących jawne kwantyfikatory. Podczas zastępowania nazw w ciele kwantyfikatora, nazwy związane nim są usunięte ze zbioru \code{lre\_nwcs}. Nie są one zamieniane w wieloznaczniki, co rozwiązuje problem z fragmentu \ref{lst:namedwcs_explicit_forall}.

Zbiór ten jest wykorzystywany w wariancie funkcji \code{rnHsTyKi} przyjmującym argument \code{HsTyVar}. Do zamiany zmiennej typu na wielznacznik dochodzi, gdy nazwa zmiennej zostanie w nim odnaleziona. W przeciwnym razie argument traktowany jest jako zwykła zmienna.

\subsection{Testy} %%%

Poprawność rozwiązania weryfikują trzy testy. \code{T11098} to skrypt w GHCi, który znalażł się w opisie błędu. \code{NamedWildcardsAsTyVars} sprawdza, czy uaktywnienie rozszerzenia \code{NamedWildCards} nie powoduje błędów kompilacji w poprawnych programach, lecz zawierających zmienną zaczynająca się od podkreślnika w kontekście innym niż sygnatura typu, podobnie jak w przykładzie \ref{lst:namedwcs_not_allowed}. \code{NamedWildcardExplicitForall} testuje, czy zmienne związane przez jawnie podane kwantyfikatory są traktowane jak zwykłe zmienne, a nie zamieniane w symbole wieloznaczne. Przypomina fragment \ref{lst:namedwcs_explicit_forall}.
